<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackWu&#39;s Blog</title>
  
  <subtitle>Stay Hungry,Stay Foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuxuejun2018.github.io/"/>
  <updated>2019-04-25T05:56:46.000Z</updated>
  <id>https://wuxuejun2018.github.io/</id>
  
  <author>
    <name>Jack Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对称加密算法优化之 ChaCha20-Poly1305 算法支持</title>
    <link href="https://wuxuejun2018.github.io/2019/04/25/ChaCha20-Poly1305/"/>
    <id>https://wuxuejun2018.github.io/2019/04/25/ChaCha20-Poly1305/</id>
    <published>2019-04-25T03:51:55.000Z</published>
    <updated>2019-04-25T05:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://blog.upyun.com/wp-content/uploads/2017/09/ssl.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近几年，Google、Baidu、Facebook 等互联网巨头，不谋而合地开始大力推行 HTTPS，国内外的大型互联网公司很多也都已启用全站 HTTPS，这也是未来互联网发展的趋势；从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站，苹果 App Store 中的所有应用也都必须使用 HTTPS 加密连接。</p><a id="more"></a> <p>又拍云积极推动 HTTPS 的普及，共建安全云生态，将互联网安全提升到一个新的高度。2017年初，又拍云相继推出了免费的 Let’s Encrypt 和 TrustAsia 证书 ，并且和国际顶级 CA （包括：Symantec、GeoTrust）机构合作，提供 SSL 证书的申购、管理、部署等功能，操作流程简单方便，一键申购，与又拍云 CDN 服务完美结合，可为用户提供一站式 HTTPS 安全加速解决方案。</p><p>今天，我们在此宣布，又拍云 CDN 已经支持 Google 推出的针对移动端优化的加密套件，也即 ChaCha20-Poly1305。又拍云平台上所有的 CDN 用户都可以享受到该算法带来的好处。接下来的章节将会围绕此算法来展开介绍。</p><h3 id="对称加密算法-PK"><a href="#对称加密算法-PK" class="headerlink" title="对称加密算法 PK"></a>对称加密算法 PK</h3><p>在 TLS 握手的过程中，对称加密就是通过非对称加密算法得到的对称加密密钥。通俗的讲，就是加密（encryption）与解密（decryption）过程中使用相同的密钥。2000年10月2日，美国国家标准与技术研究所（NIST–American National Institute of Standards and Technology）选择了 Rijndael 算法作为新的高级加密标准（AES–Advanced Encryption Standard），常用的对称加密算法如下：</p><table><thead><tr><th>算法名</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>AES-128-CBC</td><td>实现简单，运行速度快</td><td>无 MAC 功能</td><td></td></tr><tr><td>AES-128-GCM</td><td>有 MAC 功能</td><td>实现复杂，速度较 CBC 慢</td><td></td></tr><tr><td>ChaCha20-Poly1305</td><td>运行速度快，适用于移动端</td><td>推出时间较短</td><td></td></tr><tr><td>RC4</td><td>实现简单，运行速度快</td><td>已经不安全</td><td></td></tr></tbody></table><p>AES-GCM 是目前常用的分组加密算法，但是其有一个缺点就是计算量大，导致性能和电量开销比较大。为了解决这个问题，intel 推出了名为 AES NI（Advanced Encryption Standard new instructions）的 x86 指令拓展集，从硬件上提供对 AES 的支持，具体参见<a href="https://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard-aes/data-protection-aes-general-technology.html" target="_blank" rel="noopener">文档</a></p><p>所以对于支持 AES NI 指令的设备来说，使用 AES-GCM 无疑是最佳选择。针对移动端，对于不支持 AES NI 的设备来说，Google 在 2014年 推出了一种新的流式加密算法 ChaCha20-Poly1305，在 ARM 平台上，性能是 AES-GCM 的 3-4 倍。</p><h3 id="ChaCha20-Poly1305-算法介绍"><a href="#ChaCha20-Poly1305-算法介绍" class="headerlink" title="ChaCha20-Poly1305 算法介绍"></a>ChaCha20-Poly1305 算法介绍</h3><p>Chacha20-Poly1305 是由 Google 专门针对移动端 CPU 优化而采用的一种新式流式加密算法，它的性能相比普通算法要提高 3 倍，在 CPU 为精简指令集的 ARM 平台上尤为显著（ARM v8前效果较明显）。其中 Chacha20 是指对称加密算法，Poly1305 是指身份认证算法。使用该算法，可减少加密解密所产生的数据量进而可以改善用户体验，减少等待时间，节省电池寿命等。由于其算法精简、安全性强、兼容性强等特点，目前 Google致力于全面将其在移动端推广。</p><ul><li>更好的性能体现</li></ul><p>从 Google 公司公布的数据来看，Chacha20-Poly1305 能够提升 30% 以上的加解密性能，可有效节省移动端耗电量。对比当前流行的加密套件 AES-GCM，在不支持 AES NI 指令的硬件设备上，该算法会引起性能问题，如大部分的智能手机、平板电脑以及可穿戴设备。总的来说，在部分移动设备上，ChaCha20-Poly1305 加密的速度是 AES 的 3 倍还多。也即在使用 ChaCha20-Poly1305 时，较旧的计算机或者移动端设备在加解密方面会花费更少的计算时间，减少加解密时间意味着更快的页面加载速度以及更少的设备电池消耗。<br>针对移动端设备，我们很容易得出这样的结论和解决方案：在具有硬件 AES 支持的 PC 电脑上，使用 AES-GCM 算法无疑是不错的选择；又拍云 CDN 平台会根据客户端支持的加密套件情况来智能选择是否提供 AES-GCM 还是 ChaCha20-Poly1305。对于最新的英特尔处理器，我们会使用标准的 AES-GCM 算法；对于没有硬件 AES 支持的设备来说，我们会优先选择  ChaCha20-Poly1305。</p><ul><li>更安全的组合方式</li></ul><p>就安全性而言，ChaCha20-Poly1305 加密套件使用了两种算法，其中 Chacha20 是指对称加密算法，Poly1305 是指身份认证算法。从 RFC 文档里面可以得知，ChaCha20 提供了 256 位的加密强度，这对于 AES-GCM 算法的 128 位的加密强度来说，已经绰绰有余。也就是说，使用 ChaCha20 作为对称加密算法来保障 HTTPS 安全性已经足够了。</p><p>Poly1305 作为身份认证算法提供身份验证，可以防止攻击者在 TLS 握手过程中，将虚假信息插入到安全的数据流中，Poly1305 提供了大约 100 位的安全性，足以阻止这类攻击。在 TLS 握手过程中，身份验证相比加密并没有那么重要，因为即使攻击者可以向数据流中添加虚假消息，在密钥信息没有被破解的情况下，也不会读取到内部的数据信息。</p><p>总之，ChaCha20-Poly1305 作为一个加密组合，可同时对数据提供机密性，完整性和真实性保证，避开了现有发现的所有安全漏洞和攻击，是一组极佳的加密套件组合。</p><h3 id="实现方式及效果"><a href="#实现方式及效果" class="headerlink" title="实现方式及效果"></a>实现方式及效果</h3><p>为了达到「针对支持 AES-NI 的终端使用 AES-GCM 算法，否则使用 ChaCha20 算法」这样的效果，服务端需要支持等价加密算法组就可以满足此要求，服务端 ssl_ciphers 配置可以参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_ciphers [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305|ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]:ECDHE+AES128:RSA+AES128:ECDHE+AES256:RSA+AES256:ECDHE+3DES:RSA+3DES</span><br></pre></td></tr></table></figure><p>方括号 “[]” 中的配置就是等价加密算法，通过以上配置可以看出，加密套件 ECDHE-ECDSA-AES128-GCM-SHA256、ECDHE-ECDSA-CHACHA20-POLY1305、ECDHE-RSA-AES128-GCM-SHA256、ECDHE-RSA-CHACHA20-POLY1305 具有相同的优先级。接下来，客户端就可以把优先希望访问的加密套件放到前面，服务端就可以根据等价算法组进行匹配，优先响应客户端支持的且排在前列的加密算法。举例说明如下：</p><p>Mac Chrome 支持的加密套件序列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cipher Suites (13 suites) :</span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca9)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca8)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)</span><br><span class="line"> Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)</span><br><span class="line"> Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)</span><br><span class="line"> Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)</span><br><span class="line"> Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)</span><br><span class="line"> Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)</span><br><span class="line"> Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</span><br></pre></td></tr></table></figure><p>按照以上服务端的配置以及等价加密算法的原理，则服务端会优先响应如下加密算法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br></pre></td></tr></table></figure><p>iphone Chrome 支持的加密套件序列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cipher Suites (10 suites) </span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xcc14)</span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xcc13) </span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b) </span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f) </span><br><span class="line">Cipher Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x009e) </span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xc00a) </span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009) </span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013) </span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014) </span><br><span class="line">Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x0033)</span><br></pre></td></tr></table></figure><p>按照以上服务端的配置以及等价加密算法的原理，则服务端会优先响应如下加密算法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cipher Suite: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xcc14)</span><br></pre></td></tr></table></figure><p>通过以上举例可以看出，Chrome 会在不同的平台会发送不同顺序的加密算法序列，而服务端会根据等价加密算法组的支持，就可以实现针对支持 AES-NI 的终端使用 AES-GCM 算法，否则使用 ChaCha20 算法的目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog.upyun.com/wp-content/uploads/2017/09/ssl.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近几年，Google、Baidu、Facebook 等互联网巨头，不谋而合地开始大力推行 HTTPS，国内外的大型互联网公司很多也都已启用全站 HTTPS，这也是未来互联网发展的趋势；从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站，苹果 App Store 中的所有应用也都必须使用 HTTPS 加密连接。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>又拍云 CDN 支持了 Brotli 了！</title>
    <link href="https://wuxuejun2018.github.io/2019/04/25/brotli/"/>
    <id>https://wuxuejun2018.github.io/2019/04/25/brotli/</id>
    <published>2019-04-25T03:40:01.000Z</published>
    <updated>2019-04-25T04:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在此宣布，又拍云 CDN 现在支持 Brotli 算法了。我们之前已经支持了 Gzip 算法，在优化网站速度方面，我们始终不遗余力的进行着新算法的支持和兼容优化。Google 的 Brotli 压缩算法将提升压缩率 20% ，从而可以使用户在不增加 CPU 消耗的情况下提升页面的加载速度，可以给用户带来更好的使用体验。</p><a id="more"></a> <p>下面我们进行一些简单的测试，来验证 Brotli 的支持情况，这里我们使用 FireFox 浏览器（版本号为 56.0.2）开发者工具来抓包测试。</p><p>测试的 URL 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wuxuejun.charmelady.net/test.js（访问域名经过又拍云 CDN 进行加速）</span><br></pre></td></tr></table></figure><p>抓包结果如下截图所示：</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/firefox_brotli.jpg"></p><p>通过 FireFox 开发者工具抓包测试 Brotli 算法，测试结果为：</p><p>1）通过请求头信息 Accept-Encoding：gzip, deflate, br 可以得知，该版本的 FireFox 浏览器支持 Brotli 压缩算法 ；</p><p>2)  又拍云 CDN 支持 Brotli ，通过响应头可以得知 CDN 边缘节点响应了一个 br 版本的资源文件，响应头内容为 Content-Encoding: br</p><p>3）原始资源文件大小为 702KB，通过 Brotli 压缩之后的大小变为了 225 KB，压缩比为 32.2%。</p><p>当然您也可以通过 Curl 命令行发起请求来进行测试，比如：</p><ul><li>Gzip 压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vo /dev/null https://wuxuejun.charmelady.net/test.js -H &quot;Accept-Encoding: gzip&quot; -w &quot;cost time: %&#123;time_total&#125;\n&quot;</span><br></pre></td></tr></table></figure><ul><li>Brotli 压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vo /dev/null https://wuxuejun.charmelady.net/test.js -H &quot;Accept-Encoding: br&quot; -w &quot;cost time: %&#123;time_total&#125;\n&quot;</span><br></pre></td></tr></table></figure><ul><li>无压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -vo /dev/null https://wuxuejun.charmelady.net/test.js -w &quot;cost time: %&#123;time_total&#125;\n&quot;</span><br></pre></td></tr></table></figure><h3 id="关于-Brotli"><a href="#关于-Brotli" class="headerlink" title="关于 Brotli"></a>关于 Brotli</h3><p>Brotli 是由 Google 于 2015 年 9 月推出的无损压缩算法，它通过用变种的 LZ77 算法，Huffman 编码和二阶文本建模进行数据压缩，是一种压缩比很高的压缩方法。根据 Google 发布的研究报告，Brotli 具有如下特点：</p><p>1）针对常见的 Web 资源内容，Brotli 的性能要比 Gzip 好 17-25%；<br>2)  Brotli 压缩级别为 1 时，压缩速度是最快的，而且此时压缩率比 gzip 压缩等级为 9（最高）时还要高；<br>3）在处理不同 HTML 文档时，brotli 依然提供了非常高的压缩率；</p><p>大多数的客户端浏览器都支持 Gzip 以及 Deflate，但是对 Brotli 的支持客户端也越来越多了，当前浏览器兼容情况如下：</p><p>截止 2017年 11 月 6日，全球客户端支持 Brotli 算法的比例达到了 70.79%，参见截图所示：</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/brotli-%E5%85%BC%E5%AE%B9%E6%80%A7.jpg"></p><p>支持 Brotli 算法的浏览器支持的内容编码类型为 br , 通过 FireFox 开发者工具抓包可以获知，FireFox 浏览器的会发起这样的请求头内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding:gzip, deflate, br</span><br></pre></td></tr></table></figure><p>如果此时服务端（这里特指 CDN 边缘节点）支持 Brotli 算法，则会响应如下响应头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: br</span><br></pre></td></tr></table></figure><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>和 Gzip 压缩特性一样，Brotli 免费开放给 CDN 平台的所有用户使用，并且该特性我们默认已经开启。这里需要说明的是，触发 Brotli 需要同时满足如下条件：</p><p>1) Content-Type 满足如下 MIME 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">text/plain</span><br><span class="line">   text/javascript</span><br><span class="line">   text/css</span><br><span class="line">   text/xml</span><br><span class="line">   text/x-component</span><br><span class="line">   application/javascript</span><br><span class="line">   application/x-javascript</span><br><span class="line">   application/xml</span><br><span class="line">   application/json</span><br><span class="line">   application/xhtml+xml</span><br><span class="line">   application/rss+xml</span><br><span class="line">   application/atom+xml</span><br><span class="line">   application/x-font-ttf</span><br><span class="line">   application/vnd.ms-fontobject</span><br><span class="line">   image/svg+xml</span><br><span class="line">   image/x-icon</span><br><span class="line">   font/opentype</span><br><span class="line">   text/html — default</span><br></pre></td></tr></table></figure><p>2）Content-Length 大于 256 字节<br>3）客户端请求头需携带 Accept-Encoding: br</p><p>值得注意的是，并不是所有的浏览器都支持 Brotli 算法，所以在 CDN 边缘节点，我们同时会提供两种文件，一个是通过 Brotli 压缩的文件，一个原始资源文件。当然在客户端不支持 Brotli 算法时，我们也可以提供 Gzip 算法来压缩原始文件并提供给客户端。这里需要声明的是在客户端同时都支持 Brotli 和 Gzip 算法的情况下，我们会优先响应 br 版本的文件。</p><p>如果您还不是我们的用户，您可以免费试用我们的 CDN 服务，即可免费测试 Brotli。作为国内首家推出 Brotli 算法的 CDN 厂商，我们在为互联网用户提供良好的用户体验的同时，也会力求减少内容提供商的 CDN 采购成本。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>1）<a href="https://en.wikipedia.org/wiki/Brotli" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Brotli</a></p><p>2）<a href="http://www.gstatic.com/b/brotlidocs/brotli-2015-09-22.pdf" target="_blank" rel="noopener">http://www.gstatic.com/b/brotlidocs/brotli-2015-09-22.pdf</a></p><p>3）<a href="http://caniuse.com/#feat=brotli" target="_blank" rel="noopener">http://caniuse.com/#feat=brotli</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们在此宣布，又拍云 CDN 现在支持 Brotli 算法了。我们之前已经支持了 Gzip 算法，在优化网站速度方面，我们始终不遗余力的进行着新算法的支持和兼容优化。Google 的 Brotli 压缩算法将提升压缩率 20% ，从而可以使用户在不增加 CPU 消耗的情况下提升页面的加载速度，可以给用户带来更好的使用体验。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何动态调节 TLS Record Size 来减少网络传输延迟？</title>
    <link href="https://wuxuejun2018.github.io/2019/04/25/tls_record_size/"/>
    <id>https://wuxuejun2018.github.io/2019/04/25/tls_record_size/</id>
    <published>2019-04-25T03:29:32.000Z</published>
    <updated>2019-04-25T04:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前面的章节里面，我们介绍了如何通过优化 HTTPS 来降低网络延迟，这些技术包括：</p><ul><li>分布式 Session 复用</li><li>OCSP Stapling</li><li>HSTS</li><li>HTTP/2</li><li>False Start</li><li>ChaCha20-Poly1305 算法</li></ul><p>经过调研，我们发现 TLS Record Size 大小会对互联网资源内容加载时间产生很大影响；事实上，在比较槽糕的网络环境下，它可以延迟接收数据的处理时长达几次往返；甚至在移动网络上，这可能会导致数百毫秒的不必要的延迟。今天我们将会从 TCP 协议层面来介绍如何通过动态调节 TLS Record Size 来减少网络传输延迟。</p><a id="more"></a> <h3 id="TLS-和-TCP"><a href="#TLS-和-TCP" class="headerlink" title="TLS 和 TCP"></a>TLS 和 TCP</h3><p>TLS 协议由记录层（TLS Record Layer）和握手层(TLS Handshake Layer)组成，记录层处于协议的最底层，为 TLS 协议提供安全可靠的连接，为高层协议提供数据封装、压缩、加密等基本功能的支持。握手层协议处于记录层协议之上，握手层协议的作用是在真正的应用数据传输之前，使客户端和服务器互相进行身份认证，协商加密算法以及生成加密密钥。其中：</p><ul><li>最大的 TLS  Record 的大小为 16KB；</li><li>每个 TLS Record 包含一个 5Byte 的头部；</li></ul><p>TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于 IP 的传输层协议。</p><p>我们知道，TLS 是建立在可靠的数据传输的基础之上，运行在 TCP 层之上，一个 TLS Record Size 由多个 TCP 包组成，通过 WireShark  抓包可以得知：一个 TLS Record 大小为 16408 Byte ，被分为了 12 TCP 包。</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/tcp_tls.png"></p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>我们知道，Nginx 默认的 ssl_buffer_size 大小为 16KB（不支持动态调整），也即一个 TLS Record Size 的大小，举个例子：<br>假如资源文件的大小为 1600KB，那么就会被拆分为 100 个 TLS Record 传送到客户端。此时会出现这样的问题：</p><p>1）TLS Record Size 越大，被拆分的 TCP 包会过多，在传输过程中，如果 TCP 出现丢包情况，那么 TLS Record 到达客户端的时间就会变长，客户端必须等到收到完整的 TLS Record 才能够进行解密，如下图所示：20KB 的资源文件，被分成了大小不同的 record 。TLS Record 及 TCP 包的关系如下图所示：</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/tls_record_size.jpg"></p><p>2）如果 TLS Record Size 较小，则 TCP 丢包对 TLS Record 的影响就较小了，但是于此同时，TLS Record 头部就变多了，可能还会降低连接的吞吐量。</p><p>所以，小的 Record Size 会产生额外的消耗；大的 Record Size 会导致延迟；所以可以根据 TCP 窗口大小来合理调整 TLS Record 大小是明智之举。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>根据以上的的论点，我们可以得出这样的结论：在 TCP 慢启动的过程中，我们可以将 TLS Record Size 调整小点；因为这个过程中 TCP 链接的拥塞窗口（cwnd ）较小，TCP 链接的吞吐量也较小；在 TCP 连接结束慢启动之后，TLS Record 的大小可以增大一些，随着时间的推移，最终将 TLS Record 的大小调整到最大（也即 16KB）。</p><p>大致的算法规则为：</p><p>1）在新连接以及 TCP 慢启动阶段，将 TLS Record 大小调整为大约 1 个 TCP 包的大小；</p><p>2）在一定的阶段，也即发送一定数量的 Record Size 之后，采用较大的 Record Size ；</p><p>3）随着时间的推移，采用最大的 Record Size 大小，也即 16KB。</p><p>为了验证这个过程，通过 WireShark 抓包进行了测试：</p><p>阶段一：在刚开始，TLS Record Size 为 1393 Byte </p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/tls_record1.png"></p><p>阶段二：一段时间之后，TLS Record Size 为 4253 Byte</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/tls_record2.png"></p><p>阶段三：最后，TLS Record Size 动态变为 16408 Byte</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/11/tls_record3.png"></p><p>通过抓包显示，也验证了上面的算法规则；</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>动态 TLS Record Size 调整是我们 HTTPS 优化过程中的一项关键技术，并且该特性我们针对平台所有的 HTTPS 加速服务都默认开启了。我们还会不断优化和升级 HTTPS 加速，致力于提供更快更安全的 HTTPS 加速解决方案，欢迎您的试用。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/" target="_blank" rel="noopener">https://www.igvita.com/2013/12/16/optimizing-nginx-tls-time-to-first-byte/</a></p><p><a href="https://hpbn.co/building-blocks-of-tcp/" target="_blank" rel="noopener">https://hpbn.co/building-blocks-of-tcp/</a></p><p><a href="https://hpbn.co/transport-layer-security-tls/" target="_blank" rel="noopener">https://hpbn.co/transport-layer-security-tls/</a></p><p><a href="https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/" target="_blank" rel="noopener">https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在前面的章节里面，我们介绍了如何通过优化 HTTPS 来降低网络延迟，这些技术包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式 Session 复用&lt;/li&gt;
&lt;li&gt;OCSP Stapling&lt;/li&gt;
&lt;li&gt;HSTS&lt;/li&gt;
&lt;li&gt;HTTP/2&lt;/li&gt;
&lt;li&gt;False Start&lt;/li&gt;
&lt;li&gt;ChaCha20-Poly1305 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过调研，我们发现 TLS Record Size 大小会对互联网资源内容加载时间产生很大影响；事实上，在比较槽糕的网络环境下，它可以延迟接收数据的处理时长达几次往返；甚至在移动网络上，这可能会导致数百毫秒的不必要的延迟。今天我们将会从 TCP 协议层面来介绍如何通过动态调节 TLS Record Size 来减少网络传输延迟。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TLS 1.3 简介以及如何开启使用？</title>
    <link href="https://wuxuejun2018.github.io/2019/04/25/ls13/"/>
    <id>https://wuxuejun2018.github.io/2019/04/25/ls13/</id>
    <published>2019-04-25T02:59:36.000Z</published>
    <updated>2019-04-25T04:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在此宣布，又拍云即将在其内容分发网络中部署 TLS 1.3，作为国内首家在其内容分发网络中部署 TLS 1.3 的 CDN 厂商，又拍云始终跟随安全及速度的步伐，为互联网世界的的安全与加速贡献着自己的一份力量。在互联网世界这个生态系统中，进行 TLS 安全协议的升级并不简单，这个需要客户端和服务端同时进行升级，并确保客户端和服务端的所有通信都是正常的。又拍云在其内容分发网络中进行了这个尝试，接下来，我们更期望主流的浏览器厂商默认可以启用 TLS 1.3。截止目前为止，目前还没有任何主流浏览器在其稳定版中默认启用 TLS 1.3。</p><a id="more"></a> <h3 id="什么是-TLS-1-3-？"><a href="#什么是-TLS-1-3-？" class="headerlink" title="什么是 TLS 1.3 ？"></a>什么是 TLS 1.3 ？</h3><p>众所周知，TLS 1.3 是一个全新的 TLS  加密协议，相比 TLS 1.2 ，它既能提高各地互联网用户的访问速度，又能增强安全性。TLS 1.3 通过移除对老旧破损的密码协议的支持，来提高性能、效率和安全性，例如：</p><ul><li>CBC 模式密码</li><li>SHA-1 散列函数</li><li>各种 Diffie-Hellman 组</li><li>RSA 密钥传输</li><li>RC4 流密码</li><li>Export ciphers</li></ul><p>它还通过简化 TLS 握手来提高速度，使其只需要一次往返，而不是之前版本中的两次。通过简化握手，可以减少延迟并提高性能。</p><p>如何在浏览器（客户端）中开启 TLS 1.3 ？</p><p>目前最新版本的 Chrome 和 Firefox  都支持 TLS 1.3，但是都需要手动开启。主要原因是 TLS 1.3 还在草案阶段。</p><p>1）在 Firefox 中手动启用 TLS 1.3</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/12/firefix.jpg"></p><p>Mozilla Firefox 用户可以通过以下方式在 Firefox 中启用 TLS 1.3 支持（ 请注意，Nightly 默认支持 TLS 1.3，而 Firefox Stable 需要专门配置以支持 TLS 1.3 ）。</p><ul><li>在 Firefox 地址栏中加载 about:config。如果显示警告屏幕，请确认您要小心，忽略安全提示；</li><li>在搜索区域搜索 security.tls.version.max</li><li>通过双击它将首选项的值更改为 4，默认为 3，如上图所示。</li></ul><p>2）在 Chrome 中手动启动 TLS 1.3</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/12/chrome_tls13.jpg"></p><p>Google Chrome 用户可以通过以下方式在 Chrome 中启用 TLS 1.3 支持（ 注意：Chrome 62  之前的版本需要将  Maximum TLS version enabled  改为 TLS 1.3 ）</p><ul><li>在浏览器的地址栏中加载 chrome://flags/。这将打开 Web 浏览器的实验页面。</li><li>在搜索区域搜索 TLS 或者 tls ，找到 TLS 1.3  选项，默认为 Default</li><li>需要将  TLS 1.3 改为 Enabled (Draft)；</li><li>重新启动 Web 浏览器。</li></ul><h4 id="如何在又拍云-CDN-（服务端）控制台开启-TLS-1-3-？"><a href="#如何在又拍云-CDN-（服务端）控制台开启-TLS-1-3-？" class="headerlink" title="如何在又拍云 CDN （服务端）控制台开启 TLS 1.3 ？"></a>如何在又拍云 CDN （服务端）控制台开启 TLS 1.3 ？</h4><p>在 又拍云 CDN 控制台，我们针对 TLS 1.3 开放了切换开关，TLS 1.3 默认为关闭状态，您可以手动开启，如截图所示：</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/12/tls13.png"></p><p>值得声明的是， CDN  是否启用 TLS 1.3 ，这个取决于客户端浏览器是否支持，如果客户端并不支持 TLS 1.3 ，则会进行协议降级，仍会使用较低的 TLS 1.2 协议进行通信。</p><h4 id="在-TLS-中，客户端和服务端如何进行版本协商？"><a href="#在-TLS-中，客户端和服务端如何进行版本协商？" class="headerlink" title="在 TLS 中，客户端和服务端如何进行版本协商？"></a>在 TLS 中，客户端和服务端如何进行版本协商？</h4><p>TLS 发展至今，经历了很多版本的迭代。从 20 世纪 90 年代后期，TLS 是从最早的安全套接层（SSL）改编而来，目前 TLS 有三个版本，分别为 TLSv1.0、TLSv1.1、TLSv1.2。目前 TLSv1.3 还在草案阶段，也是迄今为止，协议版本改造最大的一个版本。</p><p>不是所有的客户端和服务端都支持相同的 TLS 协议版本，因此进行升级变得不太可能，因为这涉及到客户端和服务端的同时升级。为了达到在 TLS 通信过程中，协议版本可以达到一致，需要客户端和服务端进行协商，TLS 版本的协商相对是比较简单的，也即客户端通知服务端，其所支持的最新的 TLS 协议版本，服务端回复它们所支持的最新的协议版本。大体过程是：</p><p>1）在进行 TLS 连接时，客户端会在连接开始时发送其支持的最高版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">client（TLSv1.2）–&gt; server</span><br></pre></td></tr></table></figure><p>2）如果服务端可以正常理解客户端所发的 TLS 协议版本，则会回复相同的版本给客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client（TLSv1.2）–&gt; server</span><br><span class="line"></span><br><span class="line">client    &lt;– server（TLSv1.2）</span><br></pre></td></tr></table></figure><p>3）如果服务端并不支持客户端所发送的通信版本，仅仅支持 TLSv1.0，则服务端回复一个 TLSv1.0 版本给客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client（TLSv1.2）–&gt; server</span><br><span class="line"></span><br><span class="line">client    &lt;– server（TLSv1.0）</span><br></pre></td></tr></table></figure><p>如果此时，客户端也支持服务端回复的协议版本，则接下来客户端和服务端所有的安全通信都会使用这一版本（ 这里指 TLSv1.0 ）。如果客户端并不支持服务端所发送的协议版本，则会导致通信失败。</p><h4 id="如何验证服务端是否支持了-TLS-1-3-？"><a href="#如何验证服务端是否支持了-TLS-1-3-？" class="headerlink" title="如何验证服务端是否支持了 TLS 1.3 ？"></a>如何验证服务端是否支持了 TLS 1.3 ？</h4><p>可以直接通过  Qualys SSL Labs’s SSL Server Test  工具来验证是否支持 TLS 1.3 了 ，如截图所示：</p><p><img src="https://blog.upyun.com/wp-content/uploads/2017/12/tls13.jpg"></p><p>以上，可以得知，客户端以及服务端都支持 TLS 1.3 才可以使用  TLS 1.3  进行通信。如果您使用了 CDN 服务，需要 CDN 厂商的内容分发网络中部署 TLS 1.3 才可以正常启用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们在此宣布，又拍云即将在其内容分发网络中部署 TLS 1.3，作为国内首家在其内容分发网络中部署 TLS 1.3 的 CDN 厂商，又拍云始终跟随安全及速度的步伐，为互联网世界的的安全与加速贡献着自己的一份力量。在互联网世界这个生态系统中，进行 TLS 安全协议的升级并不简单，这个需要客户端和服务端同时进行升级，并确保客户端和服务端的所有通信都是正常的。又拍云在其内容分发网络中进行了这个尝试，接下来，我们更期望主流的浏览器厂商默认可以启用 TLS 1.3。截止目前为止，目前还没有任何主流浏览器在其稳定版中默认启用 TLS 1.3。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>测试页面</title>
    <link href="https://wuxuejun2018.github.io/2019/02/13/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/"/>
    <id>https://wuxuejun2018.github.io/2019/02/13/测试页面/</id>
    <published>2019-02-13T07:48:46.000Z</published>
    <updated>2019-02-13T07:49:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>欢迎来到我的博客世界！！！！</p><a id="more"></a> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到我的博客世界！！！！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何在 CentOS 7 下安装 Nginx</title>
    <link href="https://wuxuejun2018.github.io/2018/04/21/%E5%A6%82%E4%BD%95%E5%9C%A8-CentOS-7-%E4%B8%8B%E5%AE%89%E8%A3%85-Nginx/"/>
    <id>https://wuxuejun2018.github.io/2018/04/21/如何在-CentOS-7-下安装-Nginx/</id>
    <published>2018-04-21T08:39:00.000Z</published>
    <updated>2018-04-24T14:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1）gcc 环境安装</p><p>安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，执行命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p>2）zlib 库安装</p><p>zlib 库提供了很多种压缩和解压缩的方式， Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><a id="more"></a> <p>3）pcre 库安装</p><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p>4）openssl 安装</p><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p>5）Nginx 源码下载</p><p>进入 Nginx <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a>下载页面，下载最新稳定版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="如何安装-Nginx"><a href="#如何安装-Nginx" class="headerlink" title="如何安装 Nginx"></a>如何安装 Nginx</h3><p>1）解压并进入目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf nginx-1.14.0.tar.gz</span><br><span class="line">cd nginx-1.14.0</span><br></pre></td></tr></table></figure><p>2）默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>3）编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="如何启动-Nginx"><a href="#如何启动-Nginx" class="headerlink" title="如何启动 Nginx"></a>如何启动 Nginx</h3><p>进入启动目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>1) 启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>2）停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s quit</span><br><span class="line"></span><br><span class="line">此方式停止步骤是待 Nginx 进程处理任务完毕进行停止。</span><br><span class="line"></span><br><span class="line">./nginx -s stop</span><br><span class="line"></span><br><span class="line">此方式相当于先查出 Nginx进程 id 再使用 kill 命令强制杀掉进程</span><br></pre></td></tr></table></figure><p>3）重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="Nginx-测试"><a href="#Nginx-测试" class="headerlink" title="Nginx 测试"></a>Nginx 测试</h3><p>启动 Nginx 之后，在浏览器输入该机器的 IP 地址，进入如下页面，即可说明 Nginx 成功安装并且启动成功了。</p><p><img src="http://images.statics.9696e.com/wp-content/uploads/2014/11/nginx_default.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;1）gcc 环境安装&lt;/p&gt;
&lt;p&gt;安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，执行命令为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install gcc-c++&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）zlib 库安装&lt;/p&gt;
&lt;p&gt;zlib 库提供了很多种压缩和解压缩的方式， Nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install -y zlib zlib-devel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://wuxuejun2018.github.io/categories/Nginx/"/>
    
      <category term="CentOS" scheme="https://wuxuejun2018.github.io/categories/Nginx/CentOS/"/>
    
    
      <category term="Nginx" scheme="https://wuxuejun2018.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>CDN 服务支持 HTTP/2 Server Push 特性</title>
    <link href="https://wuxuejun2018.github.io/2018/04/18/HTTP-2-Server-push-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wuxuejun2018.github.io/2018/04/18/HTTP-2-Server-push-介绍/</id>
    <published>2018-04-18T13:23:00.000Z</published>
    <updated>2019-04-25T03:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很长一段时间内，<code>Nginx</code> 并不支持 <code>HTTP/2</code> 的 <code>Server Push</code> 特性。好消息是最新版本的 <code>Nginx 1.13.9</code> 已支持该特性，详情请移步 <a href="https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/" target="_blank" rel="noopener">Nginx 官方博客</a>。这个特性的目的是让服务端将部分资源主动推送给客户端（浏览器），节约了客户端需要使用这些资源再次发送 GET 请求所消耗的时间。</p><p>又拍云在 <code>Nginx</code> 基础上，已在其 CDN 网络中全网支持 <code>HTTP/2</code> 的 <code>Server Push</code> 特性，这是既又拍云 CDN 全网支持 <code>TLS 1.3</code> 之后又一重要特性。我们将不遗余力的保持新特性的更新迭代，为全网用户带来更加快速的访问体验。</p><a id="more"></a> <p>本文接下来将围绕如下 3 个方面来介绍 <code>Server Push</code> 特性：</p><ul><li>何为 Server Push</li><li>如何使用 Server Push</li><li>如何验证 Server Push 是否生效</li></ul><h3 id="何为-Server-Push"><a href="#何为-Server-Push" class="headerlink" title="何为 Server Push"></a>何为 Server Push</h3><p><code>Server Push</code> 是 <code>HTTP/2</code> 规范中引入的一种新技术，也即服务端在没有被客户端明确的询问下，抢先的 “推送” 一些网站资源给客户端（浏览器）。该特性只要被正确的使用，可以达到很好的页面访问效果。为了更方便的理解，下文将进行对比分析：</p><ul><li>未使用 <code>Server Push</code> 特性</li></ul><p><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cbf9347f-24a2-4634-8a14-36ff95725dd6/normal-server-response.png"></p><p>图片来源：<a href="http://www.smashingmagazine.com" target="_blank" rel="noopener">www.smashingmagazine.com</a></p><p>WEB 浏览器访问 WEB 服务端遵循着请求-响应模式，也即 WEB 浏览器请求一个资源，WEB 服务器响应一个资源。以常规的网页为例，当请求一个 <code>/index.html</code> 后，WEB 服务端响应一个 <code>/index.html</code> 页面给 WEB 浏览器，此时 WEB 浏览器会去解析该 <code>/index.html</code> 页面，发现还需要去加载 JS、CSS、图片等资源，此时客户端会依次去请求这些资源。这无形当中影响了首屏渲染的时间，不利于页面快速加载和渲染。</p><ul><li>已使用 <code>Server Push</code> 特性</li></ul><p><img src="http://provide.smashingmagazine.com/server-push-response.svg" height="300" width="600"></p><p>图片来源：<a href="http://www.smashingmagazine.com" target="_blank" rel="noopener">www.smashingmagazine.com</a></p><p>使用服务器推送（Server Push）技术之后，当 WEB 浏览器请求 <code>/index.html</code> 之后，WEB 服务端会直接将需要推送的资源一并发给 WEB 浏览器，而不需要 WEB 浏览器进行依次请求，这减少了 WEB 浏览器进行 GET 请求所消耗的时间。</p><h3 id="如何使用-Server-Push"><a href="#如何使用-Server-Push" class="headerlink" title="如何使用 Server Push"></a>如何使用 Server Push</h3><p>又拍云 CDN 支持 <code>Server Push</code> 特性可以通过如下两种方式来实现：</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>利用 HTTP 的 <code>Link</code> 首部，这在 W3C <a href="https://www.w3.org/TR/preload/#server-push-http-2" target="_blank" rel="noopener">Preload</a> 工作草案中有详细描述。示例为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link: &lt;/static/css/style.css&gt;; rel=preload; as=style;</span><br></pre></td></tr></table></figure><p>其中，<code>Link</code> 首部中 <code>as</code> 是必选的，它告诉了浏览器推送的资源类型，例如 <code>as=style</code> 表明了推送的资源是一个样式表，除了样式表，您还可以推送其他的内容类型，详情参见<a href="https://w3c.github.io/preload/#link-element-interface-extensions" target="_blank" rel="noopener">支持的内容类型</a>。如果需要进行多资源推送，可以进行如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link: &lt;/static/css/styles.css&gt;; rel=preload; as=style, &lt;/js/scripts.js&gt;; rel=preload; as=script, &lt;/img/logo.png&gt;; rel=preload; as=image</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>在 CDN 控制台进行自定义 <code>Server Push</code> 配置，此时您无需在源站进行修改，例如：</p><p>匹配路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.html</span><br></pre></td></tr></table></figure><p>推送资源为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/static/123.css</span><br><span class="line">/static/456.js</span><br></pre></td></tr></table></figure><p>在 CDN 控制台的配置如截图所示：</p><p><img src="http://upyun-assets.b0.upaiyun.com/docs/cdn/config/upyun-cdn-config-http2-server-push.png" height="300" width="600"></p><p>其中【匹配路径】为必填项，【推送资源】为非必填项。</p><p>以上两种方式，需要注意如下事项：</p><ul><li><p>如果源站已经通过 <code>Link</code> 首部来实现服务器推送，在 CDN 端的配置只需要配置【匹配路径】即可，无需配置【推送资源】选项；其中通过 <code>Link</code> 首部推送资源的方式， CDN 已经默认开启；</p></li><li><p>如果在 CDN 端进行自定义 <code>Server Push</code> 推送资源配置，则优先级会高于源站设置的 <code>Link</code> 首部；</p></li><li><p>无论何种实现方式，总的（包括 <code>Link</code> 首部和 CDN 自定义的方式）推送资源数量不超过 8 个。</p></li></ul><h3 id="如何验证-Server-Push-是否生效"><a href="#如何验证-Server-Push-是否生效" class="headerlink" title="如何验证 Server Push 是否生效"></a>如何验证 Server Push 是否生效</h3><p><strong>1）通过 <code>Google Chrome</code> 浏览器进行测试</strong></p><p>在 CDN 控制台进行了如下配置：</p><p><img src="https://upyun-assets.b0.upaiyun.com/docs/blog/https_server_push_test.png" height="300" width="600"></p><p>通过 <code>Google Chrome</code> 开发者工具进行抓包查看，推送的资源都被 <code>Push</code> 了，如截图所示：</p><p><img src="http://upyun-assets.b0.upaiyun.com/docs/blog/https_server-push_upyun_club_index_html.png" height="300" width="600"></p><p>查看 <code>/index.html</code> 资源响应头信息，并查看 <code>x-upyun-h2-pushed</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">age: 501691</span><br><span class="line">cache-control: max-age=691200</span><br><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html</span><br><span class="line">date: Thu, 19 Apr 2018 05:32:26 GMT</span><br><span class="line">etag: W/&quot;86ef9cae8d9f9e1205b25357e78a149b&quot;</span><br><span class="line">expires: Sat, 21 Apr 2018 10:10:55 GMT</span><br><span class="line">last-modified: Fri, 13 Apr 2018 10:10:45 GMT</span><br><span class="line">server: marco/2.1</span><br><span class="line">set-cookie: UPYUNPUSH=582825323-1696419771-1484613131-3932011035; Max-Age=7200</span><br><span class="line">status: 200</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">via: T.205.M, V.403-zj-fud-207, S.mix-sd-dst-035, T.40.M, V.mix-sd-dst-044, T.136.H, M.cun-sd-lyi1-136</span><br><span class="line">x-content-type: text/html</span><br><span class="line">x-request-id: 04dc2c7db2c509af1efc7d7252f0c2ce; 319efa6d981c0cb8dfb2b389368284f4</span><br><span class="line">x-source: U/200</span><br><span class="line">x-upyun-h2-pushed: /image/meinv1.jpg; /image/meinv2.jpg; /image/meinv3.jpg; /image/meinv4.jpg</span><br></pre></td></tr></table></figure><p>其中，<code>x-upyun-h2-pushed</code> 字段内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-upyun-h2-pushed: /image/meinv1.jpg; /image/meinv2.jpg; /image/meinv3.jpg; /image/meinv4.jpg</span><br></pre></td></tr></table></figure><p>也可以说明所配置的推送资源被成功 <code>Push</code> 了。</p><p><strong>2）通过 <a href="http://www.nghttp2.org/" target="_blank" rel="noopener">nghttp</a> 工具进行测试</strong></p><p>测试命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nghttp -ans https://server-push.upyun.club/index.html</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id  responseEnd requestStart  process code size request path</span><br><span class="line"> 13   +112.01ms        +69us 111.94ms  200  167 /index.html</span><br><span class="line">  8      +1.31s *   +56.96ms    1.25s  200 314K /image/meinv4.jpg</span><br><span class="line">  6      +2.17s *   +56.95ms    2.11s  200 628K /image/meinv3.jpg</span><br><span class="line">  4      +2.34s *   +56.94ms    2.28s  200 717K /image/meinv2.jpg</span><br><span class="line">  2      +2.42s *   +56.91ms    2.36s  200 726K /image/meinv1.jpg</span><br></pre></td></tr></table></figure><p>从测试结果中可以看出，被推推送的资源在 <code>requestStart</code> 栏左侧以星号标记了出来。</p><h3 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h3><p><code>Server Push</code> 作为 <code>HTTP/2</code> 最激动人心的特性之一，在性能提升方面是一大突破和挑战。又拍云紧紧跟随时代的步伐，寄希望为互联网用户提供更安全、更快的加速体验。与此同时，我们也很高兴成为国内首家推出 <code>Server Push</code> 功能的 CDN 厂商。我们期待您的测试和使用。更多反馈意见，请回复该博客，谢谢！</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="https://www.cloudflare.com/website-optimization/http2/serverpush/" target="_blank" rel="noopener">https://www.cloudflare.com/website-optimization/http2/serverpush/</a></p><p><a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/" target="_blank" rel="noopener">https://www.smashingmagazine.com/2017/04/guide-http2-server-push/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;很长一段时间内，&lt;code&gt;Nginx&lt;/code&gt; 并不支持 &lt;code&gt;HTTP/2&lt;/code&gt; 的 &lt;code&gt;Server Push&lt;/code&gt; 特性。好消息是最新版本的 &lt;code&gt;Nginx 1.13.9&lt;/code&gt; 已支持该特性，详情请移步 &lt;a href=&quot;https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx 官方博客&lt;/a&gt;。这个特性的目的是让服务端将部分资源主动推送给客户端（浏览器），节约了客户端需要使用这些资源再次发送 GET 请求所消耗的时间。&lt;/p&gt;
&lt;p&gt;又拍云在 &lt;code&gt;Nginx&lt;/code&gt; 基础上，已在其 CDN 网络中全网支持 &lt;code&gt;HTTP/2&lt;/code&gt; 的 &lt;code&gt;Server Push&lt;/code&gt; 特性，这是既又拍云 CDN 全网支持 &lt;code&gt;TLS 1.3&lt;/code&gt; 之后又一重要特性。我们将不遗余力的保持新特性的更新迭代，为全网用户带来更加快速的访问体验。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
